1. Chrome频繁访问导致socket卡死，Safari/wget无此异常
原因：在访问时，epoll返回相应的socket(ET)，调用recv接收数据。但是因为Chrome在访问的时候会触发两次或以上的请求，导致socket被阻塞。
解决：循环recv到返回－1且error为11为止，确保已经读完再作处理。

2. 服务端关后重启无法接收到请求
原因：服务端监听的端口未释放，导致绑定失败
解决：设置监听socket为SO_REUSEADDR，复用端口

3. 请求数据被截断
原因：在面对POST请求时，把缓冲区简单转换为string，而POST中所携带的数据可能会截断字符串
解决：将缓冲区截取分为header和data再处理

4. operator new在调用malloc时core dumped
原因：相应的缓冲区内存被释放/覆盖。在换用可扩展缓冲区时，扩展后指针指向新缓冲区，原缓冲区被释放，而由于外部调用仍使用指向原缓冲区的指针，导致错乱
解决：实时获取缓冲区指针

5. 模板函数声明和实现分离报错
原因：模板函数在编译中就会实例化，若把声明和定义分开，编译器在头文件中只找到了模版函数的声明，因此留下call指令后把锅甩给连接器，期待连接时通过入口找到相应的实现。由于C++规定，当一个模板不被用到的时侯就不该被实例化出来。因为对该模版函数的调用仅包含了头文件，所以放在实现文件(定义)中的模版也就没有被实例化。最后导致在连接时找不到相应的二进制实现。
解决：模版函数在头文件中实现
